# java-java总结
五片内存：寄存器，本地方法区，方法去，堆，栈堆：数组，对象，也就是封装好的实体栈：局部变量。
堆得变量都有默认初始化
构造代码块：所有的对象进行初始化，所有的对象都会调用一个代码块构造函数：给相对应的对象进行初始化，具有针对性
this：代表对象，就是锁在函数所属对象的引用（在构造函数中必须是第一行） 静态方法：只能访问静态成员。不能使用this，super
静态变量存在方法区。成员变量在堆内存
静态代码块：有静态关键字标识的代码块，只执行一次静态代码块>构造代码块>构造函数
单例模式：保证一个类在内存中的对象唯一性代码体现：私有化构造函数
创建私有并静态的本类对象
定义公有并静态的方法，返回该对象
//饿汉式class Single{
private Single(){}//私有化构造函数
private static Single s=new Single();//创建私有并静态的本类对象public static Single getInstance(){//定义公有并静态的方法，返回该对象return s;
}
}
 
//懒汉式:延迟加载class Single2{ private Single2(){}
private static Single2 s=null; public static Single2 getInstance(){ if(s==null)
s=new Single2(); return s;
}
}
java不支持多继承，但是支持多重继承

子类实例化过程：首先调用父类的构造函数，子类所有的构造函数都会默认访问父类的空构造函 数，
每一个子类构造函数第一行隐藏super（）；如果父类没有空构造，子类构造
函数
必须通过super指定访问父类构造函数；如果子类构造函数中用this来指定子类
自己
的构造函数，被调用的构造函数一样会访问父类的构造函数
super()和this()不可出现在相同的构造函数中
方法的覆盖：子类权限大于等于父类方法权限。要么都静态，要么都不静态final：修饰类，方法，变量
被final修饰的类不可被继承被final修饰的方法不可被继承
被final修饰的变量是常量，只能赋值一次抽象类：abstract
抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（不可描述
变量
抽象方法只能定义方法声明，不可以出现函数体抽象对象不可以被实例化
只有通过子类继承抽象类并覆盖了抽象类所有的抽象方法后，该子类才可以实例化，否
则还是抽象类
抽象类有构造函数，用来给子类对象进行初始化
抽象类中可以定义非抽象方法，但是抽象方法一定在抽象类中abstract不可以和final，private，static共存
接口：关键字interface
接口成员：全局变量，抽象方法。
变量（public static final) 方法(public abstract) 类和类之间是继承关系，类和接口是实现的关系 继承extends，实现implements
接口可以被多实现，接口的出现避免了单继承的局限性
java中存在多继承吗？（存在，接口和接口之间存在着继承关系，接口可以多继承接口） 接口设计的特点（1.对外提供的规则，2.功能的拓展.3降低了耦合性）
抽象类和接口的区别：1.抽象类只能被单继承，接口需要被实现，可以多实现
2.抽象类可以定义非抽象方法，子类可以直接继承使用，接口的抽

象方法，需要子类去实现


3.抽象类使用的是is a关系，接口是like a的关系
4.抽象类的成员修饰符可以自定义，接口成员修饰符固定public

多态：体现：父类引用或者接口的引用只想了自己的子类对象//Animal a=new Cat（）；

优点：提高了程序的扩展性
弊端：只能访问子类中父类具备的方法，不可以访问子类的特有方法前提：必须要有继承或者实现，通常会有覆盖操作
instanceof：判断对象是否实现了指定的接口或继承了指定的类对象 instanceof 类型（true，false）
Object：所有类的直接或间接父类。
具体方法：equals（比较地址，等同于==）（通常被复写） toString（转换成String类型）（通常被复写） Class getClass（获取运行的字节码文件）
int hashCode（返回对象的哈希码值）（通常被复写）
内部类：A类需要直接访问B类成员。而B又需要建立A的对象，可以直接将A定义在B的内部 内部类可以直接访问外部类成员，外部类必须建立内部类对象才能访问内部类class Out{
int num=4; class inner{ void show(){
System.out.println(num);
}
}
public void method(){ inner in=new inner(); in.show();//调用内部类方法
}
}
内部类定义在外部类成员位置上，可以使用修饰符1.默认修饰符：out.inner in=new out.new inner();
（很少用）
2.私有修饰符：被私有化，封装好，不允许其他程序直接访问
3.静态修饰符：如果内部类被静态修饰，相当于外部类，只能访问外部类的静态成员
（如果内部类中定义了静态成员，则内部类必须是静态的） 内部类编译后的文件名：“外部类名$内部类名.java”
为什么内部类可以直接访问外部类成员（内部类有一个外部类的引用 外部类名.this） 当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。
匿名内部类：没有名字的内部类，就是一个匿名子类对象。前提：内部类必须继承一个 类或许实现接口，格式：new 父类名&接口名(){定义子类成员或者覆盖父类方法}.方法
new Object(){ void show(){

System.out.println("1321");
}
}.show();
异常：编译异常和运行异常
try对应多个catch时，如果有父类的catch语句，一定放在下面throw用于跑出异常对象，用在函数中，后面跟异常对象
throws用于跑出异常类，后面跟异常类名，可以跟多个，用逗号隔开，用在函数上   两种异常的区别：编译被检查的异常在函数中杯跑出，函数必须声明，否则编译失败
需要调用者对该异常进行处理
运行时异常如果在函数内被抛出，在函数上不需要声明不需要调用者处理，异常发生时，程序无法继续运行
功能内部如果出现异常，内部可以处理，就try； 如果处理不了，就声明出来，让调用者处理
finally：主要用于关闭用户资源，无论是否发生异常，资源必须关闭System.exit(0);//退出jvm，只有这样finally不执行
常见异常：角标越界异常（IndexOutOfBoundsExceptions） 空指针异常（NullPointerException）
类型转换异常（ClassCastException） 范 围 public protected default private
同一类 √		√	√	√
同一包√		√	√
子类	√	√	
不同包√			
常见包名：java.lang核心包，自动导入java.awt java图形界面开发
javax.swing 提供所有的windows桌面应用程序的控件java.net 用于java网络编程
java.io 读写操作
java.util 工具包，时间对象，集合框架java.applet application+let客户端java小程序
多线程：
进程：一个程序就是一个进程，就是一个应用程序运行时的内存分配空间
线程：进程的一个程序控制单元，一条执行的路径。进程负责应用程序的空间标识，线 程负责程序的执行顺序
一个进程至少有一个线程运行，当一个进程中出现多个线程，称之为多线程应用程序， 每个线程在栈区中都有自己的执行空间，方法区，变量
在jvm启动时，主线程调用main函数，当产生垃圾时，会运行垃圾回收器代码

随机性：cpu快速切换，哪个线程获取到了cpu的执行权，哪个线程就执行返回当前现成的名称：Thread.currentThread().getName()
线程要运行的代码都统一放在了run方法中
线程运行必须通过类的start方法（1.启动线程 2.jvm调用run方法） 创建线程的第一种方式：继承Thread，子类复写run方法
1.定义类继承Thread类
2.复写run，将运行的代码写在run方法中
3.创建Thread类的子类对象，创建线程对象
4.调用线程的start方法，开启线程，执行run方法线程的状态：就绪，运行，阻塞，销毁
第二种方式：实现Runnable接口1.定义类实现Runnable接口2.覆盖接口的run方法
3.通过Thread类常见线程对象
4.将实现了Runnable接口的子类对象作为实际参数传递给Thread类的构造函数 5.调用Thread对象的start方法，开启线程
cat a=new a();
Thread t1=new Thread(a);//创建线程t1.start;
第二种方式的优点：通过继承Thread可以完成多线程，但是一个类已经有了父类， 就不可以继承其他类了。所以Runnable接口避免了单继承的局限性
多线程安全问题：将操作共享数据的语句在某一时段让一个线程执行完，其他线程无法 进来执行就可以保证线程安全。
解决多线程安全的方法：同步代码块格式：synchronize（对象）{
//同步代码块
}
好处：解决了线程安全
弊端：降低性能，判断锁需要消耗资源，产生了死锁同步的前提：有两个或两个以上的线程
多个线程用同一个锁
同步函数：将同步关键字定义在函数上。
线程暂停，后期开新的模块详细叙述，较为复杂。String：字符串被初始化就不可改变，存放在方法区的常量池中。
equals方法比较的是内容，==比较的是地址将字符数组转换成字符串 new String(char[])
length()字符串长度,char charAt(int index)指定位置字符
